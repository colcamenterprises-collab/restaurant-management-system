Step 1: Run Migration to Add/Fix Columns
Create and run this script in Replit (new file: server/migrations/fix-schema.js). Execute: node server/migrations/fix-schema.js.

javascript

Collapse

Unwrap

Run

Copy
const { Pool } = require('pg');
require('dotenv').config();

const pool = new Pool({ connectionString: process.env.NEON_DB_URL });

async function fixSchema() {
  try {
    await pool.query(`
      -- Remove obsolete columns
      ALTER TABLE daily_stock_sales
      DROP COLUMN IF EXISTS foodpanda_sales;
      
      -- Add missing columns if not exist
      ADD COLUMN IF NOT EXISTS wages jsonb DEFAULT '[]'::jsonb,
      ADD COLUMN IF NOT EXISTS drink_stock jsonb,
      ADD COLUMN IF NOT EXISTS fresh_food jsonb,
      ADD COLUMN IF NOT EXISTS frozen_food jsonb,
      ADD COLUMN IF NOT EXISTS shelf_items jsonb,
      ADD COLUMN IF NOT EXISTS kitchen_items jsonb,
      ADD COLUMN IF NOT EXISTS packaging_items jsonb,
      ADD COLUMN IF NOT EXISTS shopping jsonb;
    `);
    console.log('Schema fixed: Removed foodpanda_sales, added wages and category JSONB columns.');
  } catch (err) {
    console.error('Schema fix error:', err.message);
  } finally {
    await pool.end();
  }
}

fixSchema();
If Drizzle Kit is preferred (from log), add to package.json scripts: "migrate": "drizzle-kit push --yes", then run npm run migrate.

Step 2: Seed Items from CSV to DB on Startup
Update backend (e.g., server.js) to seed suppliers/items into a dedicated "suppliers" table (create if missing) on app start. This ensures all items (e.g., Topside Beef in Fresh Food, French Fries Box in Packaging) are always available, preventing "missing" issues.

First, add migration for "suppliers" table if needed (run once):

sql

Collapse

Unwrap

Copy
CREATE TABLE IF NOT EXISTS suppliers (
  id SERIAL PRIMARY KEY,
  item TEXT NOT NULL,
  internal_category TEXT,
  supplier TEXT,
  brand TEXT,
  sku TEXT,
  cost NUMERIC,
  packaging_qty TEXT,
  unit_measurement TEXT,
  portion_size TEXT,
  minimum_stock_amount TEXT,
  reviewed_date TEXT,
  notes TEXT
);
Then, in server.js (at top, before app.listen):

javascript

Collapse

Unwrap

Run

Copy
const fs = require('fs');
const path = require('path');
const { neon } = require('@neondatabase/serverless');

async function seedSuppliers() {
  try {
    const csvPath = path.join(__dirname, 'data/Food Costings - Supplier List - Portions - Final Prices Makro.csv');
    const csvData = fs.readFileSync(csvPath, 'utf8');
    const lines = csvData.split('\n').slice(1); // Skip header
    for (const line of lines) {
      if (!line.trim()) continue;
      const [item, category, supplier, brand, sku, cost, packagingQty, unit, portionSize, minStock, reviewedDate, notes] = line.split(',');
      const sql = `
        INSERT INTO suppliers (item, internal_category, supplier, brand, sku, cost, packaging_qty, unit_measurement, portion_size, minimum_stock_amount, reviewed_date, notes)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
        ON CONFLICT (item) DO UPDATE SET cost = EXCLUDED.cost; -- Upsert to keep updated
      `;
      await neon(sql, [item, category, supplier, brand, sku, parseFloat(cost) || 0, packagingQty, unit, portionSize, minStock, reviewedDate, notes]);
    }
    console.log('Suppliers seeded from CSV successfully.');
  } catch (err) {
    console.error('Seeding error:', err.message);
  }
}

// Call on startup
seedSuppliers();
Step 3: Update Form to Load from DB
In client/src/pages/DailyShiftForm.tsx, update to fetch suppliers from new endpoint /api/suppliers (add in routes.ts: app.get('/api/suppliers', async (req, res) => res.json(await neon('SELECT * FROM suppliers')));).

Then, in form component:

tsx

Collapse

Unwrap

Copy
import { useEffect, useState } from 'react';
import axios from 'axios';
// ... other imports

const DailyShiftForm = () => {
  const [suppliers, setSuppliers] = useState([]);
  const [formValues, setFormValues] = useState({ /* default fields */ });
  // ... existing state

  useEffect(() => {
    axios.get('/api/suppliers').then(res => setSuppliers(res.data)).catch(err => console.error(err));
  }, []);

  // Group by category for sections
  const grouped = suppliers.reduce((acc, s) => {
    const cat = s.internal_category || 'Other';
    acc[cat] = acc[cat] || [];
    acc[cat].push(s);
    return acc;
  }, {});

  // Render sections dynamically
  return (
    <form onSubmit={handleSubmit}>
      {Object.entries(grouped).map(([cat, items]) => (
        <div key={cat}>
          <h2>{cat} Inventory</h2>
          {items.map(item => (
            <input key={item.id} placeholder={item.item} /* ... */ />
          ))}
          <button type="button">+ Add {cat} Item</button>
        </div>
      ))}
      {/* Wages, other fields */}
      <button type="submit">Submit Daily Shift Form</button>
    </form>
  );
};
Step 4: Startup Schema Check
Add to server.js (before listen):

javascript

Collapse

Unwrap

Run

Copy
async function checkSchema() {
  try {
    const result = await neon(`SELECT column_name FROM information_schema.columns WHERE table_name = 'daily_stock_sales'`);
    const columns = result.rows.map(r => r.column_name);
    if (!columns.includes('wages')) throw new Error('Missing wages column');
    console.log('Schema valid.');
  } catch (err) {
    console.error('Schema check failed:', err.message);
    process.exit(1); // Halt if invalid
  }
}

checkSchema();