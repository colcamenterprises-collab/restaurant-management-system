Here’s a single, self-contained patch that:

Replaces the Stock Review page with a tablet-first, compact UI (Rolls, Meat, editable Drinks per brand).

Adds a locked-down backend (/api/stock-review/manual-ledger) with CSV (by day) export.

Creates schemas/tables, seeds brand list, and mounts routes safely (no clashes with analysis routes).

No external deps (CSV is generated server-side; no json2csv).


> Save the script below as PATCH_STOCK_REVIEW_V1.sh at repo root and run:

bash PATCH_STOCK_REVIEW_V1.sh



It will create/modify all files, apply the migration, mount the router in the right order, and restart instructions are at the end.


---

PATCH_STOCK_REVIEW_V1.sh

#!/usr/bin/env bash
set -e

echo "=== Stock Review: one-shot patch (frontend + backend + DB) ==="

ROOT="$(pwd)"

# -------------------------------------------------------------------
# 1) Backend: Manual Ledger Router (Express)
# -------------------------------------------------------------------
mkdir -p server/routes server/scripts server/migrations

cat > server/routes/stockReviewManual.ts <<'TS'
import { Router } from "express";
import { Pool } from "pg";

const router = Router();
const pool = new Pool({ connectionString: process.env.DATABASE_URL });

/** Fixed can brands (cans; no plain water) */
export const DRINK_BRANDS = [
  "Coke","Coke Zero","Sprite","Schweppes Manow",
  "Red Fanta","Orange Fanta","Red Singha","Yellow Singha","Pink Singha"
];

type YN = "Y" | "N";

type RollsMeatRow = {
  prev_end: number;       // int
  purchased: number;      // int (g for meat; pcs for rolls)
  sold: number;           // int (g for meat; burgers sold for rolls)
  expected: number;       // computed
  actual: number;         // int
  paid: YN;
};

type DrinkRow = {
  brand: string;
  prev_end: number;
  purchased: number;
  sold: number;
  expected: number;
  actual: number;
  variance: number;
  paid: YN;
};

function int(v: any) { const n = Number(v ?? 0); return Number.isFinite(n) ? Math.max(0, Math.trunc(n)) : 0; }
function yn(v: any): YN { return v === "Y" ? "Y" : "N"; }

function dayStr(v: string | undefined) {
  if (!v) throw new Error("Missing date (YYYY-MM-DD)");
  if (!/^\d{4}-\d{2}-\d{2}$/.test(v)) throw new Error("Invalid date");
  return v;
}

/** ensure tables */
async function ensureSchema() {
  await pool.query(`
    CREATE TABLE IF NOT EXISTS stock_ledger_day (
      day DATE PRIMARY KEY,
      rolls_prev_end INTEGER NOT NULL DEFAULT 0,
      rolls_purchased INTEGER NOT NULL DEFAULT 0,
      burgers_sold INTEGER NOT NULL DEFAULT 0,
      rolls_expected INTEGER NOT NULL DEFAULT 0,
      rolls_actual INTEGER NOT NULL DEFAULT 0,
      rolls_paid CHAR(1) NOT NULL DEFAULT 'N',
      meat_prev_end_g INTEGER NOT NULL DEFAULT 0,
      meat_purchased_g INTEGER NOT NULL DEFAULT 0,
      meat_sold_g INTEGER NOT NULL DEFAULT 0,
      meat_expected_g INTEGER NOT NULL DEFAULT 0,
      meat_actual_g INTEGER NOT NULL DEFAULT 0,
      meat_paid CHAR(1) NOT NULL DEFAULT 'N',
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW()
    );
    CREATE TABLE IF NOT EXISTS stock_ledger_drinks (
      day DATE NOT NULL,
      brand TEXT NOT NULL,
      prev_end INTEGER NOT NULL DEFAULT 0,
      purchased INTEGER NOT NULL DEFAULT 0,
      sold INTEGER NOT NULL DEFAULT 0,
      expected INTEGER NOT NULL DEFAULT 0,
      actual INTEGER NOT NULL DEFAULT 0,
      variance INTEGER NOT NULL DEFAULT 0,
      paid CHAR(1) NOT NULL DEFAULT 'N',
      created_at TIMESTAMP DEFAULT NOW(),
      updated_at TIMESTAMP DEFAULT NOW(),
      PRIMARY KEY (day, brand)
    );
  `);
}

/** GET ?date=YYYY-MM-DD -> one day */
router.get("/manual-ledger", async (req, res) => {
  try {
    await ensureSchema();
    const day = dayStr(String(req.query.date || ""));
    const base = await pool.query(`SELECT * FROM stock_ledger_day WHERE day = $1`, [day]);
    const drinks = await pool.query(`SELECT * FROM stock_ledger_drinks WHERE day = $1 ORDER BY brand`, [day]);

    // build default drinks set for missing brands
    const existing = new Map(drinks.rows.map((r:any)=>[r.brand, r]));
    const rows = DRINK_BRANDS.map(b => existing.get(b) || {
      day, brand: b, prev_end:0, purchased:0, sold:0, expected:0, actual:0, variance:0, paid:"N"
    });

    res.json({
      ok: true,
      day,
      rolls: base.rowCount
        ? {
            prev_end: base.rows[0].rolls_prev_end,
            purchased: base.rows[0].rolls_purchased,
            sold: base.rows[0].burgers_sold,
            expected: base.rows[0].rolls_expected,
            actual: base.rows[0].rolls_actual,
            paid: base.rows[0].rolls_paid
          }
        : { prev_end:0, purchased:0, sold:0, expected:0, actual:0, paid:"N" },
      meat: base.rowCount
        ? {
            prev_end: base.rows[0].meat_prev_end_g,
            purchased: base.rows[0].meat_purchased_g,
            sold: base.rows[0].meat_sold_g,
            expected: base.rows[0].meat_expected_g,
            actual: base.rows[0].meat_actual_g,
            paid: base.rows[0].meat_paid
          }
        : { prev_end:0, purchased:0, sold:0, expected:0, actual:0, paid:"N" },
      drinks: rows
    });
  } catch (e:any) {
    res.status(400).json({ ok:false, error: e.message });
  }
});

/** UPSERT one day { day, rolls, meat, drinks[] }  */
router.post("/manual-ledger", async (req, res) => {
  try {
    await ensureSchema();
    const day = dayStr(String(req.body?.day || req.query?.date || ""));
    const rollsReq: RollsMeatRow = {
      prev_end: int(req.body?.rolls?.prev_end),
      purchased: int(req.body?.rolls?.purchased),
      sold: int(req.body?.rolls?.sold),
      expected: int(req.body?.rolls?.expected),
      actual: int(req.body?.rolls?.actual),
      paid: yn(req.body?.rolls?.paid),
    };
    const meatReq: RollsMeatRow = {
      prev_end: int(req.body?.meat?.prev_end),
      purchased: int(req.body?.meat?.purchased),
      sold: int(req.body?.meat?.sold),
      expected: int(req.body?.meat?.expected),
      actual: int(req.body?.meat?.actual),
      paid: yn(req.body?.meat?.paid),
    };
    const drinksReq: DrinkRow[] = Array.isArray(req.body?.drinks) ? req.body.drinks : [];
    // Validate brands & compute variance
    const cleaned: DrinkRow[] = drinksReq
      .filter((r:any)=> DRINK_BRANDS.includes(String(r.brand)))
      .map((r:any)=> {
        const prev = int(r.prev_end), pur = int(r.purchased), sold = int(r.sold), act = int(r.actual);
        const exp = int((r.expected ?? (prev + pur - sold)));
        return { brand: r.brand, prev_end: prev, purchased: pur, sold, expected: exp, actual: act, variance: act - exp, paid: yn(r.paid) };
      });

    await pool.query(`
      INSERT INTO stock_ledger_day(
        day, rolls_prev_end, rolls_purchased, burgers_sold, rolls_expected, rolls_actual, rolls_paid,
        meat_prev_end_g, meat_purchased_g, meat_sold_g, meat_expected_g, meat_actual_g, meat_paid, updated_at
      ) VALUES(
        $1,$2,$3,$4,$5,$6,$7,
        $8,$9,$10,$11,$12,$13,NOW()
      )
      ON CONFLICT (day) DO UPDATE SET
        rolls_prev_end = EXCLUDED.rolls_prev_end,
        rolls_purchased = EXCLUDED.rolls_purchased,
        burgers_sold = EXCLUDED.burgers_sold,
        rolls_expected = EXCLUDED.rolls_expected,
        rolls_actual = EXCLUDED.rolls_actual,
        rolls_paid = EXCLUDED.rolls_paid,
        meat_prev_end_g = EXCLUDED.meat_prev_end_g,
        meat_purchased_g = EXCLUDED.meat_purchased_g,
        meat_sold_g = EXCLUDED.meat_sold_g,
        meat_expected_g = EXCLUDED.meat_expected_g,
        meat_actual_g = EXCLUDED.meat_actual_g,
        meat_paid = EXCLUDED.meat_paid,
        updated_at = NOW()
    `, [
      day, rollsReq.prev_end, rollsReq.purchased, rollsReq.sold, rollsReq.expected, rollsReq.actual, rollsReq.paid,
      meatReq.prev_end, meatReq.purchased, meatReq.sold, meatReq.expected, meatReq.actual, meatReq.paid
    ]);

    // Upsert drinks
    for (const d of cleaned) {
      await pool.query(`
        INSERT INTO stock_ledger_drinks(day, brand, prev_end, purchased, sold, expected, actual, variance, paid, updated_at)
        VALUES($1,$2,$3,$4,$5,$6,$7,$8,$9,NOW())
        ON CONFLICT (day, brand) DO UPDATE SET
          prev_end = EXCLUDED.prev_end,
          purchased = EXCLUDED.purchased,
          sold = EXCLUDED.sold,
          expected = EXCLUDED.expected,
          actual = EXCLUDED.actual,
          variance = EXCLUDED.variance,
          paid = EXCLUDED.paid,
          updated_at = NOW()
      `, [day, d.brand, d.prev_end, d.purchased, d.sold, d.expected, d.actual, d.variance, d.paid]);
    }

    res.json({ ok:true, day, saved_drinks: cleaned.length });
  } catch (e:any) {
    res.status(400).json({ ok:false, error: e.message });
  }
});

/** CSV export for a day */
router.get("/manual-ledger/export.csv", async (req,res) => {
  try {
    await ensureSchema();
    const day = dayStr(String(req.query.date || ""));
    const base = await pool.query(`SELECT * FROM stock_ledger_day WHERE day = $1`, [day]);
    const drinks = await pool.query(`SELECT * FROM stock_ledger_drinks WHERE day = $1 ORDER BY brand`, [day]);

    // header
    const fields = [
      "date","rolls_prev_end","rolls_purchased","burgers_sold","rolls_expected","rolls_actual","rolls_variance","rolls_paid",
      "meat_prev_end_g","meat_purchased_g","meat_sold_g","meat_expected_g","meat_actual_g","meat_variance_g","meat_paid"
    ];
    // add per brand columns
    for (const b of DRINK_BRANDS) {
      fields.push(
        `${b}_prev`,`${b}_purchased`,`${b}_sold`,`${b}_expected`,`${b}_actual`,`${b}_variance`,`${b}_paid`
      );
    }

    function esc(v:any){ const s = String(v ?? ""); return `"${s.replace(/"/g,'""')}"`; }

    const row:any = {};
    const baseRow = base.rowCount ? base.rows[0] : {};
    row["date"] = day;
    row["rolls_prev_end"]= baseRow.rolls_prev_end ?? 0;
    row["rolls_purchased"]= baseRow.rolls_purchased ?? 0;
    row["burgers_sold"]= baseRow.burgers_sold ?? 0;
    row["rolls_expected"]= baseRow.rolls_expected ?? 0;
    row["rolls_actual"]= baseRow.rolls_actual ?? 0;
    row["rolls_variance"]= (row["rolls_actual"] - row["rolls_expected"]) || 0;
    row["rolls_paid"]= baseRow.rolls_paid ?? "N";
    row["meat_prev_end_g"]= baseRow.meat_prev_end_g ?? 0;
    row["meat_purchased_g"]= baseRow.meat_purchased_g ?? 0;
    row["meat_sold_g"]= baseRow.meat_sold_g ?? 0;
    row["meat_expected_g"]= baseRow.meat_expected_g ?? 0;
    row["meat_actual_g"]= baseRow.meat_actual_g ?? 0;
    row["meat_variance_g"]= (row["meat_actual_g"] - row["meat_expected_g"]) || 0;
    row["meat_paid"]= baseRow.meat_paid ?? "N";

    const map = new Map(drinks.rows.map((r:any)=>[r.brand, r]));
    for (const b of DRINK_BRANDS) {
      const r:any = map.get(b) || {};
      row[`${b}_prev`] = r.prev_end ?? 0;
      row[`${b}_purchased`] = r.purchased ?? 0;
      row[`${b}_sold`] = r.sold ?? 0;
      row[`${b}_expected`] = r.expected ?? 0;
      row[`${b}_actual`] = r.actual ?? 0;
      row[`${b}_variance`] = r.variance ?? 0;
      row[`${b}_paid`] = r.paid ?? "N";
    }

    const header = fields.join(",");
    const data = fields.map(f => esc(row[f])).join(",");

    res.setHeader("Content-Type","text/csv; charset=utf-8");
    res.setHeader("Content-Disposition", `attachment; filename="stock_review_${day}.csv"`);
    res.send(header + "\n" + data + "\n");
  } catch (e:any) {
    res.status(400).json({ ok:false, error: e.message });
  }
});

export default router;
TS

# -------------------------------------------------------------------
# 2) Mount router safely (before any /api/analysis/:date catch-alls)
#     Use Node patcher to avoid brittle sed
# -------------------------------------------------------------------
cat > server/scripts/patch_routes_stock_review.mjs <<'JS'
import fs from "fs";
const file = "server/routes.ts";
const src = fs.readFileSync(file, "utf8");

// add import if missing
let out = src;
if (!out.includes("stockReviewManual")) {
  out = out.replace(
    /(\n\s*import .*?;\s*)+(?=[\s\S]*?\bconst app =)/m,
    (m) => m + `\nimport stockReviewManual from "./routes/stockReviewManual";\n`
  );
}

// ensure mount BEFORE dynamic analysis routes
if (!out.includes('app.use("/api/stock-review/manual-ledger"')) {
  // try to mount near the top of mounts
  out = out.replace(
    /(\bconst app = [\s\S]*?{[\s\S]*?}\);\s*)/m,
    (m) => m
  );
  // Insert mount right after any other early mounts but before /api/analysis
  out = out.replace(
    /(app\.use\([^\n]*\);[\s\S]*?)\n(?=app\.(get|use)\(["']\/api\/analysis)/m,
    (m) => m + `\napp.use("/api/stock-review/manual-ledger", stockReviewManual);\n`
  );
  // Fallback: if no /api/analysis marker, just add once near end before export
  if (!out.includes('app.use("/api/stock-review/manual-ledger"')) {
    out = out.replace(/(\nexport default app;)/, `\napp.use("/api/stock-review/manual-ledger", stockReviewManual);\n$1`);
  }
}

fs.writeFileSync(file, out, "utf8");
console.log("Patched server/routes.ts ✅");
JS

node server/scripts/patch_routes_stock_review.mjs

# -------------------------------------------------------------------
# 3) DB migration file (optional; router auto-creates if missing)
# -------------------------------------------------------------------
cat > server/migrations/20251015_stock_review.sql <<'SQL'
-- idempotent schema (also created at runtime)
CREATE TABLE IF NOT EXISTS stock_ledger_day (
  day DATE PRIMARY KEY,
  rolls_prev_end INTEGER NOT NULL DEFAULT 0,
  rolls_purchased INTEGER NOT NULL DEFAULT 0,
  burgers_sold INTEGER NOT NULL DEFAULT 0,
  rolls_expected INTEGER NOT NULL DEFAULT 0,
  rolls_actual INTEGER NOT NULL DEFAULT 0,
  rolls_paid CHAR(1) NOT NULL DEFAULT 'N',
  meat_prev_end_g INTEGER NOT NULL DEFAULT 0,
  meat_purchased_g INTEGER NOT NULL DEFAULT 0,
  meat_sold_g INTEGER NOT NULL DEFAULT 0,
  meat_expected_g INTEGER NOT NULL DEFAULT 0,
  meat_actual_g INTEGER NOT NULL DEFAULT 0,
  meat_paid CHAR(1) NOT NULL DEFAULT 'N',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE IF NOT EXISTS stock_ledger_drinks (
  day DATE NOT NULL,
  brand TEXT NOT NULL,
  prev_end INTEGER NOT NULL DEFAULT 0,
  purchased INTEGER NOT NULL DEFAULT 0,
  sold INTEGER NOT NULL DEFAULT 0,
  expected INTEGER NOT NULL DEFAULT 0,
  actual INTEGER NOT NULL DEFAULT 0,
  variance INTEGER NOT NULL DEFAULT 0,
  paid CHAR(1) NOT NULL DEFAULT 'N',
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW(),
  PRIMARY KEY (day, brand)
);
SQL

# lightweight runner
cat > server/scripts/apply_migration_stock_review.mjs <<'JS'
import fs from "fs";
import { Client } from "pg";
const sql = fs.readFileSync("server/migrations/20251015_stock_review.sql","utf8");
const client = new Client({ connectionString: process.env.DATABASE_URL });
await client.connect();
await client.query(sql);
await client.end();
console.log("Applied stock review migration ✅");
JS

node server/scripts/apply_migration_stock_review.mjs

# -------------------------------------------------------------------
# 4) Frontend: tablet-first Stock Review page (replace body)
# -------------------------------------------------------------------
mkdir -p client/src/pages/analysis

cat > client/src/pages/analysis/StockReview.tsx <<'TSX'
import React, { useEffect, useMemo, useState } from "react";

type YN = "Y"|"N";

const BRANDS = [
  "Coke","Coke Zero","Sprite","Schweppes Manow",
  "Red Fanta","Orange Fanta","Red Singha","Yellow Singha","Pink Singha"
];

type RollsMeat = { prev_end:number; purchased:number; sold:number; expected:number; actual:number; paid:YN };
type Drink = { brand:string; prev_end:number; purchased:number; sold:number; expected:number; actual:number; variance:number; paid:YN };

const nz = (v:any)=> Number.isFinite(Number(v)) ? Math.max(0, Math.trunc(Number(v))) : 0;
const yn = (v:any):YN => v==="Y" ? "Y" : "N";

export default function StockReview(){
  const today = new Date().toISOString().slice(0,10);
  const [day, setDay] = useState<string>(today);
  const [loading, setLoading] = useState(false);

  const [rolls, setRolls] = useState<RollsMeat>({prev_end:0,purchased:0,sold:0,expected:0,actual:0,paid:"N"});
  const [meat, setMeat] = useState<RollsMeat>({prev_end:0,purchased:0,sold:0,expected:0,actual:0,paid:"N"});
  const [drinks, setDrinks] = useState<Drink[]>(BRANDS.map(b => ({brand:b, prev_end:0,purchased:0,sold:0,expected:0,actual:0,variance:0,paid:"N"})));

  const rollsVar = useMemo(()=> nz(rolls.actual) - nz(rolls.expected), [rolls]);
  const meatVar = useMemo(()=> nz(meat.actual) - nz(meat.expected), [meat]);

  // recompute exp/variance on edit
  useEffect(()=>{
    setRolls(r => ({...r, expected: nz(r.prev_end) + nz(r.purchased) - nz(r.sold)}));
  }, [rolls.prev_end, rolls.purchased, rolls.sold]);
  useEffect(()=>{
    setMeat(m => ({...m, expected: nz(m.prev_end) + nz(m.purchased) - nz(m.sold)}));
  }, [meat.prev_end, meat.purchased, meat.sold]);
  useEffect(()=>{
    setDrinks(ds => ds.map(d => {
      const expected = nz(d.prev_end) + nz(d.purchased) - nz(d.sold);
      return {...d, expected, variance: nz(d.actual) - expected};
    }));
  }, [JSON.stringify(drinks.map(d=>[d.prev_end,d.purchased,d.sold,d.actual]))]);

  async function load(){
    setLoading(true);
    const res = await fetch(`/api/stock-review/manual-ledger?date=${day}`);
    const data = await res.json();
    if (data?.ok){
      setRolls(data.rolls);
      setMeat(data.meat);
      const map = new Map(data.drinks.map((r:Drink)=>[r.brand,r]));
      setDrinks(BRANDS.map(b => map.get(b) || {brand:b, prev_end:0,purchased:0,sold:0,expected:0,actual:0,variance:0,paid:"N"}));
    }
    setLoading(false);
  }

  useEffect(()=>{ load(); }, [day]);

  async function save(){
    const body = { day, rolls, meat, drinks };
    const res = await fetch(`/api/stock-review/manual-ledger`, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body)
    });
    const j = await res.json();
    if (!j.ok) alert(j.error || "Save failed");
  }

  function exportCSV(){
    window.open(`/api/stock-review/manual-ledger/export.csv?date=${day}`, "_blank");
  }

  const pill = (n:number)=> `text-xs px-2 py-1 rounded-full ${n===0 ? "bg-green-100 text-green-700" : "bg-red-100 text-red-700"}`;

  return (
    <div className="mx-auto max-w-5xl p-3 md:p-6">
      {/* Sticky toolbar */}
      <div className="sticky top-0 z-10 bg-white/90 backdrop-blur pb-2">
        <div className="flex items-center gap-2">
          <h1 className="text-xl font-semibold flex-1">Stock Review</h1>
          <input type="date" className="h-10 rounded-xl border px-3 text-sm"
            value={day} onChange={e=>setDay(e.target.value)} />
          <button onClick={save} className="h-10 rounded-xl bg-slate-900 text-white px-4 text-sm">Save</button>
          <button onClick={exportCSV} className="h-10 rounded-xl border px-4 text-sm">CSV (Day)</button>
        </div>
      </div>

      {/* Rolls */}
      <section className="mt-3 rounded-2xl border p-3 md:p-4">
        <div className="flex items-center justify-between mb-2">
          <h2 className="text-base font-medium">Rolls (Buns)</h2>
          <span className={pill(rollsVar)}>Variance: {rollsVar}</span>
        </div>
        <div className="grid grid-cols-2 md:grid-cols-7 gap-2">
          {[
            ["Prev End", "prev_end"],
            ["Purchased", "purchased"],
            ["Burgers Sold", "sold"],
            ["Expected", "expected", true],
            ["Actual", "actual"],
            ["Paid", "paid"]
          ].map(([label, key, ro]:any)=>(
            <label key={String(key)} className="text-[12px] text-slate-600">
              <div className="mb-1">{label}</div>
              {key==="paid" ? (
                <select value={rolls.paid} onChange={e=>setRolls({...rolls, paid: yn(e.target.value)})}
                        className="h-10 w-full rounded-xl border px-2 text-base">
                  <option value="N">N</option><option value="Y">Y</option>
                </select>
              ) : (
                <input inputMode="numeric" pattern="[0-9]*"
                       value={String((rolls as any)[key])}
                       onChange={e=> setRolls({...rolls, [key]: nz(e.target.value)})}
                       readOnly={!!ro}
                       className="h-10 w-full rounded-xl border px-3 text-base"/>
              )}
            </label>
          ))}
        </div>
      </section>

      {/* Meat */}
      <section className="mt-3 rounded-2xl border p-3 md:p-4">
        <div className="flex items-center justify-between mb-2">
          <h2 className="text-base font-medium">Meat (grams)</h2>
          <span className={pill(meatVar)}>Variance: {meatVar} g</span>
        </div>
        <div className="grid grid-cols-2 md:grid-cols-7 gap-2">
          {[
            ["Prev End (g)", "prev_end"],
            ["Purchased (g)", "purchased"],
            ["Sold (g)", "sold"],
            ["Expected (g)", "expected", true],
            ["Actual (g)", "actual"],
            ["Paid", "paid"]
          ].map(([label, key, ro]:any)=>(
            <label key={String(key)} className="text-[12px] text-slate-600">
              <div className="mb-1">{label}</div>
              {key==="paid" ? (
                <select value={meat.paid} onChange={e=>setMeat({...meat, paid: yn(e.target.value)})}
                        className="h-10 w-full rounded-xl border px-2 text-base">
                  <option value="N">N</option><option value="Y">Y</option>
                </select>
              ) : (
                <input inputMode="numeric" pattern="[0-9]*"
                       value={String((meat as any)[key])}
                       onChange={e=> setMeat({...meat, [key]: nz(e.target.value)})}
                       readOnly={!!ro}
                       className="h-10 w-full rounded-xl border px-3 text-base"/>
              )}
            </label>
          ))}
        </div>
      </section>

      {/* Drinks */}
      <section className="mt-3 rounded-2xl border p-0 overflow-hidden">
        <div className="flex items-center justify-between p-3 md:p-4">
          <h2 className="text-base font-medium">Drinks (Cans)</h2>
        </div>
        <div className="overflow-x-auto">
          <table className="w-full text-sm">
            <thead className="bg-slate-50">
              <tr className="text-left">
                {["Brand","Prev","Purch","Sold","Exp","Act","Var","Paid"].map(h=>(
                  <th key={h} className="px-3 py-2 font-medium">{h}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {drinks.map((d, idx)=>(
                <tr key={d.brand} className="border-t">
                  <td className="px-3 py-2">{d.brand}</td>
                  {(["prev_end","purchased","sold"] as const).map(k=>(
                    <td key={k} className="px-3 py-2">
                      <input inputMode="numeric" pattern="[0-9]*"
                        value={String((d as any)[k])}
                        onChange={e=>{
                          const v = nz(e.target.value);
                          setDrinks(s => s.map((r,i)=> i===idx ? {...r, [k]: v} : r));
                        }}
                        className="h-10 w-24 rounded-xl border px-2 text-base"/>
                    </td>
                  ))}
                  <td className="px-3 py-2 text-slate-500">{d.expected}</td>
                  <td className="px-3 py-2">
                    <input inputMode="numeric" pattern="[0-9]*"
                      value={String(d.actual)}
                      onChange={e=>{
                        const v = nz(e.target.value);
                        setDrinks(s => s.map((r,i)=> i===idx ? {...r, actual: v, variance: v - (r.expected ?? 0)} : r));
                      }}
                      className="h-10 w-24 rounded-xl border px-2 text-base"/>
                  </td>
                  <td className={`px-3 py-2 ${d.variance===0?"text-green-600":"text-red-600"}`}>{d.variance}</td>
                  <td className="px-3 py-2">
                    <select value={d.paid}
                      onChange={e=> setDrinks(s => s.map((r,i)=> i===idx ? {...r, paid: (e.target.value as YN)} : r))}
                      className="h-10 w-16 rounded-xl border px-2 text-base">
                      <option value="N">N</option><option value="Y">Y</option>
                    </select>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      </section>

      {loading && <div className="mt-3 text-sm text-slate-500">Loading…</div>}
    </div>
  );
}
TSX

echo "Frontend + backend files written."

echo "=== Patch complete. Next steps ==="
echo "1) Restart the dev server (or your Replit workflow) so routes + new page load."
echo "2) Open /analysis/stock-review"
echo "   - Top sticky bar: pick a date, enter values, Save, CSV (Day)."
echo "3) Backend endpoints:"
echo "   - GET  /api/stock-review/manual-ledger?date=YYYY-MM-DD"
echo "   - POST /api/stock-review/manual-ledger        (body: { day, rolls, meat, drinks[] })"
echo "   - GET  /api/stock-review/manual-ledger/export.csv?date=YYYY-MM-DD"

echo "Done ✅"


---

What you’ll see (acceptance)

No KPI tiles on Stock Review — just the sticky toolbar + three compact sections.

Drinks has one editable row per brand (cans; no water).

Save persists the selected date’s entries; reload returns them.

CSV (Day) downloads a proper flat file with:

Rolls + Meat fields, and

For each brand: _prev, _purchased, _sold, _expected, _actual, _variance, _paid.


Page is tablet-first: large tap targets, compact spacing, no desktop baggage.


If anything blocks (e.g., route mount order), the script’s Node patcher already places the router before analysis dynamic routes, so /api/stock-review/manual-ledger won’t collide.