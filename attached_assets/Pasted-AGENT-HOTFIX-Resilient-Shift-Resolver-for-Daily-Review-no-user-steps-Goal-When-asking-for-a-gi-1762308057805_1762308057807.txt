AGENT HOTFIX — Resilient Shift Resolver for Daily Review (no user steps)

Goal

When asking for a given shift date D (e.g., 2025-11-04), the Daily Review endpoints must find the correct Form and POS Shift even if they were saved under D-1 or D+1 due to timezone/UTC conversion. No schema changes.

Guardrails

❌ No prisma db push, no resets, no schema edits.

✅ Only edit server code in server/routes/analysisDailyReview.ts (or its shared utils) and add a small resolver helper.

✅ Commit & push yourself.


Tasks

1) Add a resilient resolver helper

Create server/lib/findShiftRows.ts:

// server/lib/findShiftRows.ts
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();

/**
 * Business rule: a "shift date D" is the shift that runs from
 * local BKK D 18:00 -> D+1 03:00.
 * Storage may have written "shiftDate" as D, D-1, or D+1 depending on UTC logic.
 * This resolver:
 *   1) tries exact match on shiftDate = D
 *   2) falls back to neighbors D-1 and D+1
 *   3) if multiple candidates, choose the one whose createdAt falls in
 *      [D 18:00 BKK, D+1 03:00 BKK] when converted to UTC; otherwise pick latest.
 */

function toUtc(date: Date) {
  // Date is already in local runtime tz; we only need ISO strings for Prisma filters if used.
  return date.toISOString();
}

function bkkWindowUtc(dateStr: string) {
  // Build BKK window without extra deps, using Intl to get BKK timestamps
  const asBkk = (y: number, m: number, d: number, h: number, mi = 0) =>
    new Date(new Date(Date.UTC(y, m - 1, d, h - 7, mi)).toISOString()); // Asia/Bangkok = UTC+7

  const [y, m, d] = dateStr.split("-").map(Number);
  const startBkk = asBkk(y, m, d, 18, 0);         // D 18:00 BKK -> UTC
  // next day for 03:00 BKK
  const endDate = new Date(Date.UTC(y, m - 1, d));
  endDate.setUTCDate(endDate.getUTCDate() + 1);
  const y2 = endDate.getUTCFullYear();
  const m2 = endDate.getUTCMonth() + 1;
  const d2 = endDate.getUTCDate();
  const endBkk = asBkk(y2, m2, d2, 3, 0);         // D+1 03:00 BKK -> UTC

  return { startUtc: startBkk, endUtc: endBkk };
}

export async function findDailySalesRowFor(dateStr: string) {
  const candidates = await prisma.daily_sales_v2.findMany({
    where: { shiftDate: { in: [dateStr, prev(dateStr), next(dateStr)] }, deletedAt: null },
    orderBy: { createdAt: "desc" },
  });
  if (!candidates.length) return null;

  const { startUtc, endUtc } = bkkWindowUtc(dateStr);
  const inWindow = candidates.find(r => {
    const c = new Date(r.createdAt);
    return c >= startUtc && c <= endUtc;
  });
  return inWindow ?? candidates[0];
}

export async function findPosShiftRowFor(dateStr: string) {
  const candidates = await prisma.pos_shift_report.findMany({
    where: { shiftDate: { in: [dateStr, prev(dateStr), next(dateStr)] } },
    orderBy: { createdAt: "desc" },
  });
  if (!candidates.length) return null;

  const { startUtc, endUtc } = bkkWindowUtc(dateStr);
  const inWindow = candidates.find(r => {
    const c = new Date(r.createdAt);
    return c >= startUtc && c <= endUtc;
  });
  return inWindow ?? candidates[0];
}

function prev(s: string) {
  const d = new Date(s + "T00:00:00Z");
  d.setUTCDate(d.getUTCDate() - 1);
  return d.toISOString().slice(0,10);
}
function next(s: string) {
  const d = new Date(s + "T00:00:00Z");
  d.setUTCDate(d.getUTCDate() + 1);
  return d.toISOString().slice(0,10);
}

> Note: We avoid extra libraries and keep everything additive.



2) Use the resolver in Daily Review endpoints

Edit server/routes/analysisDailyReview.ts:

import { findDailySalesRowFor, findPosShiftRowFor } from "../lib/findShiftRows";
import { extractFormExpenseTotals, extractPosExpenseTotals } from "../lib/expenseTotals";

// inside GET /api/analysis/daily-comparison
const date = String(req.query.date);
// replace previous direct "findFirst where shiftDate = date" with:
const formRow = await findDailySalesRowFor(date);
const posRow  = await findPosShiftRowFor(date);

// keep existing total extraction (normalizers)
const formExp = extractFormExpenseTotals(formRow ?? {});
const posExp  = extractPosExpenseTotals(posRow ?? {});
// build and return response as before

And in /api/analysis/daily-comparison-range:

For each day in the loop, call the same findDailySalesRowFor(day) and findPosShiftRowFor(day).


3) Add lightweight debug (optional)

Allow ?debug=1 to include which underlying shiftDate row was selected (helps ops):

const debug = req.query.debug === "1";
return res.json({
  date,
  ...(debug ? { debug: { formShiftDate: formRow?.shiftDate, posShiftDate: posRow?.shiftDate } } : {}),
  form: { expenses: formExp, ... },
  pos:  { expenses: posExp,  ... },
  variance
});

4) Verify the reported issue (Nov 4)

Run these and paste outputs in the agent summary:

DATE=2025-11-04
MONTH=2025-11

curl -s "http://localhost:5000/api/analysis/daily-comparison?date=$DATE&debug=1" \
 | jq '{date, debug, form: .form.expenses, pos: .pos.expenses}'

curl -s "http://localhost:5000/api/analysis/daily-comparison-range?month=$MONTH" \
 | jq '.[] | select(.date=="'"$DATE"'") | {date, form: .form.expenses, pos: .pos.expenses}'

Expectations:

Both form and pos are now present for 2025-11-04.

If the stored rows were under 3rd or 5th, debug shows the chosen underlying shiftDate.


5) Commit & push (agent does this)

git add server/lib/findShiftRows.ts server/routes/analysisDailyReview.ts
git commit -m "fix(analysis): resilient shift resolver for BKK 18:00–03:00 window; handle ±1 day"
git pull --rebase origin main || true
git push -u origin main

Acceptance

[ ] For 2025-11-04, endpoints return both Form and POS with non-null expense totals.

[ ] Top Sales (Form vs POS) table shows data for Nov 4 (no “not available”).

[ ] No schema changes or destructive commands used.

[ ] Commit pushed and curl outputs included in summary.

