ere’s a drop-in Shift Summary you can paste in now. It lives under Operations → Analysis → Shift Summary, ingests your six Loyverse CSV exports, computes the KPIs you asked for, and (optionally) cross-checks against the Daily Sales form.

I’ve kept it lightweight so you can test immediately. It works without a DB migration (returns results straight after upload). If you want persistence/archiving later, I left one hook to plug in.

1) Backend — routes (Express)
server/routes/analysisShift.ts
// server/routes/analysisShift.ts
import { Router } from "express";
import multer from "multer";
import { parseLoyverseFilesToSummary } from "../services/loyverseParsers";
import { getDailySalesByDate } from "../services/dailySalesAccess"; // stub below

const upload = multer({ storage: multer.memoryStorage() });
const router = Router();

/**
 * POST /api/analysis/shift-summary/upload
 * form-data: files[] (multiple CSVs: sales-summary, item-sales-summary, payment-type-sales,
 *                      receipts, modifier-sales, shifts)
 * query: date=YYYY-MM-DD (optional; inferred from files if not provided)
 */
router.post("/upload", upload.array("files", 10), async (req, res) => {
  try {
    const date = String(req.query.date || "");
    const files = (req.files as Express.Multer.File[]) || [];
    if (!files.length) return res.status(400).json({ error: "No files uploaded" });

    const summary = await parseLoyverseFilesToSummary(files, { dateHint: date });

    // OPTIONAL: cross-check vs daily sales form (same local date)
    const daily = await getDailySalesByDate(summary.dateLocal);
    const discrepancies = buildDiscrepancies(summary, daily);

    res.json({ ok: true, dateLocal: summary.dateLocal, summary, daily, discrepancies });
  } catch (e:any) {
    console.error(e);
    res.status(500).json({ error: e.message || "Failed to parse" });
  }
});

export default router;

/** Compare POS vs Daily Sales form minimal set */
function buildDiscrepancies(summary: any, daily: any | null) {
  if (!daily) return [{ level: "info", field: "Daily Sales", message: "No Daily Sales submission found for this date." }];
  const out: any[] = [];

  const num = (x:any)=> Number(x||0);
  // POS (from uploads)
  const pos = summary.kpis;
  const pay = summary.paymentBreakdown; // {Cash, QR, Grab, Aroi Dee, Direct, Other, Card}

  // Daily Sales form fields
  const ds = {
    cashSales: num(daily.cashSales),
    qrSales: num(daily.qrSales),
    grabSales: num(daily.grabSales),
    aroiDeeSales: num(daily.aroiDeeSales),
    directSales: num(daily.directSales),
    totalSales: num(daily.totalSales)
  };

  // Simple deltas
  const checks = [
    ["Cash Sales", pay.Cash || 0, ds.cashSales],
    ["QR Sales", pay.QR || 0, ds.qrSales],
    ["Grab Sales", pay["Grab"] || 0, ds.grabSales],
    ["Aroi Dee Sales", pay["Aroi Dee"] || 0, ds.aroiDeeSales],
    ["Direct Sales", pay["Direct"] || 0, ds.directSales],
    ["Total Sales", pos.grossSales || 0, ds.totalSales]
  ];

  const THRESHOLD = 20; // THB tolerance
  for (const [label, posVal, dsVal] of checks) {
    const delta = Math.round((posVal - dsVal) * 100) / 100;
    if (Math.abs(delta) > THRESHOLD) {
      out.push({ level: "warn", field: label, message: `${label} mismatch: POS ${posVal.toFixed(0)} vs Daily ${dsVal.toFixed(0)} (Δ ${delta.toFixed(0)})` });
    }
  }
  if (!out.length) out.push({ level: "ok", field: "Reconciliation", message: "POS uploads match the Daily Sales sheet within tolerance." });
  return out;
}

server/services/loyverseParsers.ts
// server/services/loyverseParsers.ts
import { parse as csvParse } from "csv-parse/sync";

type File = { originalname: string; buffer: Buffer; mimetype: string };

const cleanNum = (v:any) => {
  if (v === null || v === undefined) return 0;
  let s = String(v).replace(/[,฿%]/g, "").trim();
  if (!s) return 0;
  const n = Number(s);
  return isFinite(n) ? n : 0;
};

const lc = (s:string)=> (s||"").toLowerCase();

function parseCSV(buf:Buffer): any[] {
  // attempt UTF-8 first, then UTF-16 tab if needed
  try {
    return csvParse(buf, { columns: true, skip_empty_lines: true });
  } catch {
    const txt = buf.toString("utf16le");
    return csvParse(txt, { columns: true, skip_empty_lines: true, delimiter: "\t" });
  }
}

export async function parseLoyverseFilesToSummary(files: File[], opts: { dateHint?: string } = {}) {
  const buckets:any = {}; // by guessed type
  for (const f of files) {
    const rows = parseCSV(f.buffer);
    const name = f.originalname.toLowerCase();
    if (name.includes("payment-type")) buckets.payment = rows;
    else if (name.includes("item-sales")) buckets.items = rows;
    else if (name.includes("modifier")) buckets.modifiers = rows;
    else if (name.includes("shift")) buckets.shifts = rows;
    else if (name.includes("receipts")) buckets.receipts = rows;
    else if (name.includes("sales-summary")) buckets.summary = rows;
    else {
      // try by headers
      const headers = Object.keys(rows[0] || {}).map(h=>h.toLowerCase());
      if (headers.includes("sales type") || headers.includes("payment type")) buckets.payment = rows;
      else if (headers.includes("item name") && headers.includes("items sold")) buckets.items = rows;
      else if (headers.includes("modifier") && headers.includes("qty")) buckets.modifiers = rows;
      else if (headers.includes("receipt number")) buckets.receipts = rows;
      else buckets.summary = rows;
    }
  }

  // 1) KPIs from summary
  const sumRows = buckets.summary || [];
  const grossSales = sumRows.reduce((a,r)=> a + cleanNum(r["Gross sales"]), 0);
  const refunds    = sumRows.reduce((a,r)=> a + cleanNum(r["Refunds"]||r["Refunded amount"]), 0);
  const netSales   = sumRows.reduce((a,r)=> a + cleanNum(r["Net sales"]), 0);

  // 2) Payment breakdown
  const payRows = buckets.payment || [];
  const paymentBreakdown:any = {};
  for (const r of payRows) {
    const label = String(r["Sales type"] || r["Payment type"] || r[Object.keys(r)[0]] || "").trim();
    const amt   = cleanNum(r["Gross sales"] || r["Amount"] || r[Object.keys(r)[1]]);
    paymentBreakdown[label] = (paymentBreakdown[label] || 0) + amt;
  }

  // Normalize keys we care about
  const normPay = {
    Cash: paymentBreakdown["Cash"] || 0,
    QR: paymentBreakdown["QR"] || paymentBreakdown["PromptPay"] || paymentBreakdown["QR PromptPay"] || 0,
    Grab: Object.keys(paymentBreakdown).filter(k=>lc(k).includes("grab")).reduce((a,k)=>a+paymentBreakdown[k],0),
    "Aroi Dee": Object.keys(paymentBreakdown).filter(k=>lc(k).includes("aroi")).reduce((a,k)=>a+paymentBreakdown[k],0),
    Direct: paymentBreakdown["Direct"] || 0,
    Other: paymentBreakdown["Other"] || 0,
    Card: paymentBreakdown["Card"] || 0
  };

  // 3) Receipts count + members (from receipts file if present)
  const recRows = buckets.receipts || [];
  const totalReceipts = recRows.length || cleanNum(sumRows[0]?.["Receipts"]);
  const memberCol = recRows.length ? Object.keys(recRows[0]).find(c=>lc(c).includes("member") || lc(c).includes("customer")) : null;
  const members = memberCol ? recRows.filter(r => String(r[memberCol]||"").trim() !== "").length : 0;

  // 4) Items (counts & top 5)
  const itemRows = buckets.items || [];
  const items = itemRows.map((r:any)=> ({
    itemName: r["Item name"] || r["Item"] || "",
    qty: cleanNum(r["Items sold"] || r["Qty"]),
    gross: cleanNum(r["Gross sales"] || r["Gross"])
  }));
  items.sort((a,b)=> (b.qty - a.qty) || (b.gross - a.gross));
  const top5 = items.slice(0,5);

  // 5) Burgers sold (heuristic contains 'burger')
  const burgersSold = items.filter(i => lc(i.itemName).includes("burger")).reduce((a,i)=>a+i.qty,0);

  // 6) Aroi/Grab from normalized pay
  const grabSales = normPay.Grab;
  const aroiDeeSales = normPay["Aroi Dee"];

  // 7) Date (local)
  let dateLocal = opts.dateHint || "";
  if (!dateLocal) {
    // try first date from receipts or summary
    const dateCol = recRows.length ? Object.keys(recRows[0]).find(c=>lc(c).includes("date")) : null;
    if (dateCol) {
      const first = String(recRows[0][dateCol]).split(" ")[0];
      dateLocal = first;
    }
  }

  return {
    dateLocal,
    kpis: {
      grossSales,
      netSales,
      refunds,
      totalReceipts,
      members,
      grabSales,
      aroiDeeSales,
      burgersSold
    },
    paymentBreakdown: normPay,
    topItems: top5,
    allItems: items
  };
}

server/services/dailySalesAccess.ts (stub)
// server/services/dailySalesAccess.ts
// Replace this with your real data access (DB query).
export async function getDailySalesByDate(dateLocal: string) {
  // Return null to skip reconciliation, or return the Daily Sales payload for that date:
  // {
  //   cashSales: number, qrSales: number, grabSales: number,
  //   aroiDeeSales: number, directSales: number, totalSales: number
  // }
  return null; // <- hook up later
}

Wire the route
// server/routes.ts
import analysisShift from "./routes/analysisShift";
export function registerRoutes(app:any){
  // ...
  app.use("/api/analysis/shift-summary", analysisShift);
  // ...
}

2) Frontend — page under Operations → Analysis
Sidebar tweak (one line)
// client/src/components/Sidebar.tsx (under Operations group)
{ label: "Analysis", path: "/operations/analysis" },
{ label: "Shift Summary", path: "/operations/analysis/shift-summary" },

Page: client/src/pages/operations/analysis/ShiftSummary.tsx
import React, { useMemo, useState } from "react";

type Summary = {
  dateLocal: string;
  summary: {
    kpis: any;
    paymentBreakdown: Record<string, number>;
    topItems: { itemName: string; qty: number; gross: number }[];
    allItems: { itemName: string; qty: number; gross: number }[];
  };
  daily: any | null;
  discrepancies: { level: "ok"|"info"|"warn"; field: string; message: string }[];
};

const THB = (n:number)=> new Intl.NumberFormat("th-TH",{style:"currency",currency:"THB",maximumFractionDigits:0}).format(n||0);

export default function ShiftSummary(){
  const [files, setFiles] = useState<FileList | null>(null);
  const [date, setDate] = useState<string>("");
  const [data, setData] = useState<Summary | null>(null);
  const [loading, setLoading] = useState(false);

  const onUpload = async ()=>{
    if (!files || !files.length) return;
    const fd = new FormData();
    Array.from(files).forEach(f=> fd.append("files", f));
    if (date) fd.append("date", date);
    setLoading(true);
    const resp = await fetch(`/api/analysis/shift-summary/upload${date?`?date=${date}`:""}`, { method: "POST", body: fd });
    const json = await resp.json();
    setLoading(false);
    if (!resp.ok) return alert(json.error || "Upload failed");
    setData(json);
  };

  const k = data?.summary?.kpis;
  const pay = data?.summary?.paymentBreakdown || {};

  return (
    <div className="bg-app min-h-screen px-6 sm:px-8 py-5" style={{ fontFamily:"Poppins, sans-serif" }}>
      <div className="flex items-baseline justify-between mb-4">
        <h1 className="text-[32px] font-extrabold tracking-tight text-[var(--heading)]">Shift Summary</h1>
        <div className="flex gap-3">
          <input type="date" className="header-pill px-3 py-2 text-sm" value={date} onChange={e=>setDate(e.target.value)} />
          <input type="file" multiple accept=".csv" onChange={e=>setFiles(e.target.files)} className="header-pill px-3 py-2 text-sm" />
          <button onClick={onUpload} disabled={loading || !files?.length} className="bg-teal-600 text-white rounded-xl px-4 py-2 text-sm">
            {loading ? "Processing…" : "Upload & Analyze"}
          </button>
        </div>
      </div>

      {/* KPIs */}
      {k && (
        <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mt-6">
          {[
            ["Gross Sales", THB(k.grossSales)],
            ["Net Sales", THB(k.netSales)],
            ["Refunds", THB(k.refunds)],
            ["Receipts", (k.totalReceipts||0).toString()],
            ["Members", (k.members||0).toString()],
            ["Grab Sales", THB(k.grabSales)],
            ["Aroi Dee Sales", THB(k.aroiDeeSales)],
            ["Burgers Sold", (k.burgersSold||0).toString()],
          ].map(([label,value])=>(
            <div key={label as string} className="rounded-2xl bg-white border p-5">
              <div className="text-xs text-[var(--muted)]">{label}</div>
              <div className="text-2xl font-semibold mt-1 tabular-nums">{value}</div>
            </div>
          ))}
        </div>
      )}

      {/* Payment breakdown */}
      {data && (
        <div className="card mt-6">
          <div className="card-inner">
            <div className="flex items-center justify-between">
              <h3 className="text-[18px] font-semibold">Payment Breakdown</h3>
            </div>
            <div className="mt-4 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
              {Object.entries(pay).map(([label, amt])=>(
                <div key={label} className="border rounded-xl p-3 bg-white">
                  <div className="flex items-center justify-between text-sm">
                    <span className="text-gray-700 font-medium">{label}</span>
                    <span className="text-gray-900 font-semibold">{THB(amt||0)}</span>
                  </div>
                  <div className="h-2 rounded-full bg-gray-200 overflow-hidden mt-2">
                    <div className="h-full bg-teal-600" style={{ width: `${Math.min(100, Math.max(0,(amt||0) / Math.max(1,(k?.grossSales||1)) * 100))}%`}}/>
                  </div>
                </div>
              ))}
            </div>
          </div>
        </div>
      )}

      {/* Top items */}
      {data?.summary?.topItems?.length ? (
        <div className="card mt-6">
          <div className="card-inner">
            <h3 className="text-[18px] font-semibold">Top 5 Items Sold</h3>
            <div className="mt-3 overflow-auto">
              <table className="min-w-[560px] w-full">
                <thead><tr><th className="p-2 text-left">Item</th><th className="p-2 text-right">Qty</th><th className="p-2 text-right">Gross</th></tr></thead>
                <tbody>
                  {data.summary.topItems.map((r,i)=>(
                    <tr key={i} className={i%2?"bg-gray-50/50":""}>
                      <td className="p-2">{r.itemName}</td>
                      <td className="p-2 text-right tabular-nums">{r.qty}</td>
                      <td className="p-2 text-right tabular-nums">{THB(r.gross)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      ) : null}

      {/* Full items table */}
      {data?.summary?.allItems?.length ? (
        <div className="card mt-6">
          <div className="card-inner">
            <h3 className="text-[18px] font-semibold">All Items Sold</h3>
            <div className="mt-3 overflow-auto">
              <table className="min-w-[720px] w-full">
                <thead><tr><th className="p-2 text-left">Item</th><th className="p-2 text-right">Qty</th><th className="p-2 text-right">Gross</th></tr></thead>
                <tbody>
                  {data.summary.allItems.map((r,i)=>(
                    <tr key={i} className={i%2?"bg-gray-50/50":""}>
                      <td className="p-2">{r.itemName}</td>
                      <td className="p-2 text-right tabular-nums">{r.qty}</td>
                      <td className="p-2 text-right tabular-nums">{THB(r.gross)}</td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>
      ) : null}

      {/* Discrepancies */}
      {data?.discrepancies?.length ? (
        <div className="card mt-6">
          <div className="card-inner">
            <h3 className="text-[18px] font-semibold">Discrepancies vs Daily Sales</h3>
            <ul className="mt-2 space-y-2">
              {data.discrepancies.map((d,idx)=>(
                <li key={idx} className={`p-3 rounded-xl border ${d.level==="warn"?"border-amber-300 bg-amber-50": d.level==="ok"?"border-green-300 bg-green-50":"border-gray-200 bg-white"}`}>
                  <div className="text-sm"><strong>{d.field}:</strong> {d.message}</div>
                </li>
              ))}
            </ul>
          </div>
        </div>
      ) : null}
    </div>
  );
}

3) Quick wiring checklist

Add routes

server/routes/analysisShift.ts and import in server/routes.ts as shown.

Add service files

server/services/loyverseParsers.ts

server/services/dailySalesAccess.ts (returns null until you wire your DB fetch)

Add page + sidebar entry

client/src/pages/operations/analysis/ShiftSummary.tsx

Update Sidebar.tsx with Shift Summary link under Operations → Analysis.

Test flow

Go to Operations → Analysis → Shift Summary

Pick date, upload your six CSVs (you can upload any subset; it auto-detects by headers)

Click Upload & Analyze

Verify KPIs, payments, top items, and discrepancies list.

4) What’s included (per your requirements)

Gross Sales, Net Sales, Refunds

Grab Sales, Aroi Dee Sales (from Payment Type file)

Payment Type breakdown (Cash, QR, Grab, Aroi Dee, Direct, Other, Card)

Number of Receipts

Number of Members

Top 5 items + All items

Total Burgers Sold (heuristic: name contains “burger” → replace with a menu map when ready)

Does the Shift Report Balance?
→ Discrepancies panel compares POS uploads to Daily Sales (hook up getDailySalesByDate to enable)