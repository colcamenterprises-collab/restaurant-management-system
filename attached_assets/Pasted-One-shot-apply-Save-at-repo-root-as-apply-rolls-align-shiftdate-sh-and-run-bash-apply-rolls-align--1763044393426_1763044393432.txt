One-shot apply

Save at repo root as apply_rolls_align_shiftdate.sh and run:
bash apply_rolls_align_shiftdate.sh

#!/usr/bin/env bash
set -euo pipefail
echo "== Rolls Ledger — shift_date alignment with runtime column detection =="

mkdir -p prisma/migrations/20251112_rolls_align_shiftdate

cat > prisma/migrations/20251112_rolls_align_shiftdate/migration.sql <<'SQL'
-- Table (kept simple)
CREATE TABLE IF NOT EXISTS rolls_ledger (
  shift_date date PRIMARY KEY,
  rolls_start integer NOT NULL DEFAULT 0,
  rolls_purchased integer NOT NULL DEFAULT 0,
  burgers_sold integer NOT NULL DEFAULT 0,
  estimated_rolls_end integer NOT NULL DEFAULT 0,
  actual_rolls_end integer,
  waste_allowance integer NOT NULL DEFAULT 4,
  variance integer,
  status text NOT NULL DEFAULT 'PENDING',
  -- meta so we can see what columns were actually used (for your audit)
  meta_start_source text,
  meta_purchase_source text,
  meta_actual_source text,
  updated_at timestamptz NOT NULL DEFAULT now()
);

-- Helpers
CREATE OR REPLACE FUNCTION tbl_exists(tbl text)
RETURNS boolean LANGUAGE sql IMMUTABLE AS $$
  SELECT EXISTS(SELECT 1 FROM information_schema.tables
    WHERE table_schema='public' AND table_name = tbl)
$$;

CREATE OR REPLACE FUNCTION col_exists(tbl text, col text)
RETURNS boolean LANGUAGE sql IMMUTABLE AS $$
  SELECT EXISTS(SELECT 1 FROM information_schema.columns
    WHERE table_schema='public' AND table_name = tbl AND column_name = col)
$$;

CREATE OR REPLACE FUNCTION first_existing_col(tbl text, cols text[])
RETURNS text LANGUAGE plpgsql IMMUTABLE AS $$
DECLARE c text;
BEGIN
  FOREACH c IN ARRAY cols LOOP
    IF (SELECT col_exists(tbl, c)) THEN
      RETURN c;
    END IF;
  END LOOP;
  RETURN NULL;
END$$;

-- Core recompute by shift_date (no time windows)
CREATE OR REPLACE FUNCTION recompute_rolls_ledger(p_date date)
RETURNS void LANGUAGE plpgsql AS $$
DECLARE
  v_prev date := (p_date - INTERVAL '1 day')::date;

  -- Daily Stock source (your v2 form; prefer drizzle table)
  stock_tbl text := CASE
                      WHEN tbl_exists('daily_stock_sales') THEN 'daily_stock_sales'
                      WHEN tbl_exists('DailyStock') THEN 'DailyStock'
                      ELSE NULL
                    END;
  stock_end_col text;   -- burger_buns_stock / rolls_end / buns_end / etc.
  stock_date_col text;  -- shift_date (preferred) or fallback (updatedAt/createdAt in Prisma)

  -- Expenses / Purchases
  use_roll_purchase boolean := tbl_exists('roll_purchase');
  exp_qty_col text;
  exp_item_col text;
  exp_date_col text;

  -- Values
  v_start int := 0;
  v_purchased int := 0;
  v_sold int := 0;
  v_est int := 0;
  v_actual int := NULL;
  v_waste int := 4;
  v_var int := NULL;

  -- meta
  m_start text := NULL;
  m_purchase text := NULL;
  m_actual text := NULL;

  sql text;
BEGIN
  -- --- START: yesterday actual ---
  -- Prefer yesterday ledger actual
  SELECT rl.actual_rolls_end INTO v_start
  FROM rolls_ledger rl WHERE rl.shift_date = v_prev;

  IF v_start IS NOT NULL THEN
    m_start := 'rolls_ledger.actual_rolls_end';
  ELSIF stock_tbl IS NOT NULL THEN
    -- pick end-of-rolls column
    stock_end_col := first_existing_col(stock_tbl, ARRAY[
      'burger_buns_stock','rolls_end','buns_end','rolls_actual','buns_stock'
    ]);

    IF stock_end_col IS NOT NULL THEN
      IF stock_tbl = 'daily_stock_sales' THEN
        -- drizzle table has shift_date; choose the latest row for v_prev
        sql := format('SELECT %I FROM %I WHERE shift_date = $1 ORDER BY COALESCE(updated_at, created_at) DESC LIMIT 1',
                      stock_end_col, stock_tbl);
        EXECUTE sql USING v_prev INTO v_start;
        IF v_start IS NOT NULL THEN m_start := stock_tbl||'.'||stock_end_col; END IF;
      ELSE
        -- Prisma "DailyStock": use updatedAt/createdAt and DATE(...) match p_date-1
        stock_date_col := CASE
          WHEN col_exists('DailyStock','shift_date') THEN 'shift_date'
          ELSE NULL
        END;
        IF stock_date_col IS NOT NULL THEN
          sql := format('SELECT %I FROM "DailyStock" WHERE %I = $1 ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1',
                        stock_end_col, stock_date_col);
          EXECUTE sql USING v_prev INTO v_start;
        ELSE
          sql := format('SELECT %I FROM "DailyStock"
                         WHERE DATE(COALESCE("updatedAt","createdAt")) = $1
                         ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1', stock_end_col);
          EXECUTE sql USING v_prev INTO v_start;
        END IF;
        IF v_start IS NOT NULL THEN m_start := 'DailyStock.'||stock_end_col; END IF;
      END IF;
    END IF;
  END IF;

  IF v_start IS NULL THEN v_start := 0; m_start := COALESCE(m_start,'default:0'); END IF;

  -- --- PURCHASED for p_date ---
  IF use_roll_purchase THEN
    -- dedicated table
    IF col_exists('roll_purchase','shift_date') THEN
      EXECUTE 'SELECT COALESCE(SUM(quantity),0)::int FROM roll_purchase WHERE shift_date = $1' USING p_date INTO v_purchased;
      m_purchase := 'roll_purchase.quantity';
    ELSE
      -- ultra fallback: date column detection
      EXECUTE 'SELECT COALESCE(SUM(quantity),0)::int FROM roll_purchase WHERE DATE(purchase_ts) = $1' USING p_date INTO v_purchased;
      m_purchase := 'roll_purchase.quantity(purchase_ts)';
    END IF;
  ELSIF tbl_exists('expenses') THEN
    exp_qty_col := first_existing_col('expenses', ARRAY['quantity','qty','units','number']);
    exp_item_col := first_existing_col('expenses', ARRAY['item','name','description','product']);
    exp_date_col := first_existing_col('expenses', ARRAY['shift_date','date','ts','created_at']);

    IF exp_qty_col IS NOT NULL AND exp_item_col IS NOT NULL AND exp_date_col IS NOT NULL THEN
      sql := format($SQL$
        SELECT COALESCE(SUM(%I),0)::int
        FROM expenses
        WHERE (lower(%I) LIKE '%%bun%%' OR lower(%I) LIKE '%%roll%%')
          AND DATE(%I) = $1
      $SQL$, exp_qty_col, exp_item_col, exp_item_col, exp_date_col);
      EXECUTE sql USING p_date INTO v_purchased;
      m_purchase := format('expenses.%s via %s', exp_qty_col, exp_item_col);
    ELSE
      v_purchased := 0; m_purchase := 'expenses:not_detected';
    END IF;
  ELSE
    v_purchased := 0; m_purchase := 'none';
  END IF;

  -- --- SOLD for p_date ---
  IF tbl_exists('analytics_shift_item') THEN
    -- prefer rolls column
    EXECUTE 'SELECT COALESCE(SUM(rolls),0)::int FROM analytics_shift_item WHERE shift_date = $1'
      USING p_date INTO v_sold;

    IF v_sold = 0 THEN
      EXECUTE $$SELECT COALESCE(SUM(qty),0)::int
               FROM analytics_shift_item
               WHERE shift_date = $1 AND lower(category) = 'burger'$$
      USING p_date INTO v_sold;
    END IF;
  END IF;

  -- --- ACTUAL END for p_date ---
  IF stock_tbl IS NOT NULL THEN
    stock_end_col := first_existing_col(stock_tbl, ARRAY[
      'burger_buns_stock','rolls_end','buns_end','rolls_actual','buns_stock'
    ]);
    IF stock_end_col IS NOT NULL THEN
      IF stock_tbl = 'daily_stock_sales' THEN
        sql := format('SELECT %I FROM %I WHERE shift_date = $1 ORDER BY COALESCE(updated_at, created_at) DESC LIMIT 1',
                      stock_end_col, stock_tbl);
        EXECUTE sql USING p_date INTO v_actual;
        IF v_actual IS NOT NULL THEN m_actual := stock_tbl||'.'||stock_end_col; END IF;
      ELSE
        stock_date_col := CASE
          WHEN col_exists('DailyStock','shift_date') THEN 'shift_date' ELSE NULL END;
        IF stock_date_col IS NOT NULL THEN
          sql := format('SELECT %I FROM "DailyStock" WHERE %I = $1 ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1',
                        stock_end_col, stock_date_col);
          EXECUTE sql USING p_date INTO v_actual;
        ELSE
          sql := format('SELECT %I FROM "DailyStock"
                         WHERE DATE(COALESCE("updatedAt","createdAt")) = $1
                         ORDER BY COALESCE("updatedAt","createdAt") DESC LIMIT 1', stock_end_col);
          EXECUTE sql USING p_date INTO v_actual;
        END IF;
        IF v_actual IS NOT NULL THEN m_actual := 'DailyStock.'||stock_end_col; END IF;
      END IF;
    END IF;
  END IF;

  -- --- assemble row ---
  v_est := v_start + v_purchased - v_sold;

  IF v_actual IS NULL THEN
    INSERT INTO rolls_ledger(shift_date, rolls_start, rolls_purchased, burgers_sold,
                             estimated_rolls_end, actual_rolls_end, waste_allowance,
                             variance, status, meta_start_source, meta_purchase_source, meta_actual_source, updated_at)
    VALUES (p_date, v_start, v_purchased, v_sold, v_est, NULL, v_waste,
            NULL, 'PENDING', m_start, m_purchase, NULL, now())
    ON CONFLICT (shift_date) DO UPDATE SET
      rolls_start = EXCLUDED.rolls_start,
      rolls_purchased = EXCLUDED.rolls_purchased,
      burgers_sold = EXCLUDED.burgers_sold,
      estimated_rolls_end = EXCLUDED.estimated_rolls_end,
      actual_rolls_end = NULL,
      variance = NULL,
      status = 'PENDING',
      meta_start_source = EXCLUDED.meta_start_source,
      meta_purchase_source = EXCLUDED.meta_purchase_source,
      meta_actual_source = NULL,
      updated_at = now();
  ELSE
    v_var := v_actual - v_est;
    INSERT INTO rolls_ledger(shift_date, rolls_start, rolls_purchased, burgers_sold,
                             estimated_rolls_end, actual_rolls_end, waste_allowance,
                             variance, status, meta_start_source, meta_purchase_source, meta_actual_source, updated_at)
    VALUES (p_date, v_start, v_purchased, v_sold, v_est, v_actual, v_waste,
            v_var, CASE WHEN abs(v_var) <= v_waste THEN 'OK' ELSE 'ALERT' END,
            m_start, m_purchase, m_actual, now())
    ON CONFLICT (shift_date) DO UPDATE SET
      rolls_start = EXCLUDED.rolls_start,
      rolls_purchased = EXCLUDED.rolls_purchased,
      burgers_sold = EXCLUDED.burgers_sold,
      estimated_rolls_end = EXCLUDED.estimated_rolls_end,
      actual_rolls_end = EXCLUDED.actual_rolls_end,
      waste_allowance = EXCLUDED.waste_allowance,
      variance = EXCLUDED.variance,
      status = EXCLUDED.status,
      meta_start_source = EXCLUDED.meta_start_source,
      meta_purchase_source = EXCLUDED.meta_purchase_source,
      meta_actual_source = EXCLUDED.meta_actual_source,
      updated_at = now();
  END IF;
END;
$$;

-- Triggers: recompute THAT date when source rows change
DO $$
BEGIN
  IF tbl_exists('daily_stock_sales') THEN
    DROP TRIGGER IF EXISTS trg_rl_recompute_dss ON daily_stock_sales;
    CREATE TRIGGER trg_rl_recompute_dss
    AFTER INSERT OR UPDATE OF shift_date, burger_buns_stock, rolls_end, updated_at, created_at
    ON daily_stock_sales
    FOR EACH ROW
    EXECUTE FUNCTION (SELECT
      (CREATE OR REPLACE FUNCTION _rl_cb_dss() RETURNS trigger AS $F$
        BEGIN PERFORM recompute_rolls_ledger(NEW.shift_date); RETURN NEW; END
      $F$ LANGUAGE plpgsql); '_rl_cb_dss'::regproc);
  END IF;
END$$;

DO $$
BEGIN
  IF tbl_exists('expenses') THEN
    DROP TRIGGER IF EXISTS trg_rl_recompute_exp ON expenses;
    CREATE TRIGGER trg_rl_recompute_exp
    AFTER INSERT OR UPDATE ON expenses
    FOR EACH ROW
    EXECUTE FUNCTION (SELECT
      (CREATE OR REPLACE FUNCTION _rl_cb_exp() RETURNS trigger AS $F$
        DECLARE d date; itm text; has_sd boolean;
        BEGIN
          has_sd := EXISTS(SELECT 1 FROM information_schema.columns
                           WHERE table_schema='public' AND table_name='expenses' AND column_name='shift_date');
          IF has_sd THEN d := NEW.shift_date;
          ELSE
            BEGIN d := DATE(NEW.ts);
            EXCEPTION WHEN undefined_column THEN d := DATE(NEW.created_at); END;
          END IF;

          -- only recompute if it's a buns/rolls line
          BEGIN itm := lower(NEW.item);
          EXCEPTION WHEN undefined_column THEN itm := lower(COALESCE(NEW.description, NEW.name::text, '')); END;
          IF (itm LIKE '%bun%' OR itm LIKE '%roll%') THEN
            PERFORM recompute_rolls_ledger(d);
          END IF;
          RETURN NEW;
        END
      $F$ LANGUAGE plpgsql); '_rl_cb_exp'::regproc);
  END IF;
END$$;

SQL

# Apply
npx prisma migrate deploy || npx prisma db push

echo "== Done. Rolls Ledger now recomputes from your existing tables by shift_date, with auto column detection. =="
echo "Quick checks:"
echo " 1) UPDATE/INSERT daily_stock_sales for a date -> ledger row updates"
echo " 2) INSERT expense with 'bun' or 'roll' for that date (with qty/quantity) -> Purchased updates"
echo " 3) SELECT * FROM rolls_ledger ORDER BY shift_date DESC LIMIT 5;"


---

How to verify (fast)

1. Update Daily Stock v2 for a known date (e.g., shift_date = 2025-11-05) with your end-of-rolls field.

Check: SELECT * FROM rolls_ledger WHERE shift_date='2025-11-05';

You should see actual_rolls_end populated and meta_actual_source telling you which column it used.



2. Add an expense line for the same shift_date where the item contains “bun” or “roll”, and a quantity.

Check: the ledger row’s rolls_purchased increases. meta_purchase_source shows which fields were used.



3. Ensure Burgers Sold already exists in analytics_shift_item for that shift_date.

If not, run whatever you use to fill analytics_shift_item (your F&B analysis compute), then re-edit the Daily Stock row (any small change) to trigger recompute.





---
