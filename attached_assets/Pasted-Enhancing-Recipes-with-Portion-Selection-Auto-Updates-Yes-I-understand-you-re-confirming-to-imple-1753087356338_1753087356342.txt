Enhancing Recipes with Portion Selection & Auto-Updates
Yes, I understand—you're confirming to implement portion selection in recipes from the ingredient list. This fits your vision for Menu Management: create a burger recipe by selecting ingredients with portions, auto-calculate cost per serving (portion * ingredient costPerPortion), break down ingredients, store as a recipe card, make downloadable (PDF), and auto-update pricing if an ingredient price changes (data accuracy critical). We'll keep it sleek/minimal (shadcn cards/table, no clutter), simple (direct DB/API), secure (DB triggers for updates), and growth-ready (extendable to AI generator).

No 3rd party tools—use Drizzle for DB, Express for API, React/shadcn for UI, jspdf for PDF download (client-side, simple). BKK time: 01:39 PM +07, July 21, 2025.

1. DB Schema Update (shared/schema.ts - Update Recipes)
Add portion to ingredients in recipes, cost calc, updatedAt.

typescript

Collapse

Unwrap

Run

Copy
export const recipes = pgTable('recipes', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 255 }),
  ingredients: jsonb('ingredients'), // [{ ingredientId: id, portion: number }]
  costPerServing: decimal('cost_per_serving', { precision: 10, scale: 2 }), // Auto-calc
  breakDown: jsonb('break_down'), // Stored breakdown JSON
  updatedAt: timestamp('updated_at').defaultNow().$onUpdate(() => new Date()),
});
Run npx drizzle-kit migrate.

2. Backend API (server/routes.ts - Update Recipes)
Auto-calc cost on save/update, trigger on ingredient change.

typescript

Collapse

Unwrap

Run

Copy
app.post('/api/recipes', async (req, res) => {
  const data = req.body;
  let cost = 0;
  const breakDown = [];
  for (const ing of data.ingredients) {
    const ingData = await db.select().from(ingredients).where(eq(ingredients.id, ing.ingredientId)).limit(1)[0];
    const ingCost = ing.portion * ingData.costPerPortion;
    cost += ingCost;
    breakDown.push({ name: ingData.name, portion: ing.portion, cost: ingCost });
  }
  data.costPerServing = cost;
  data.breakDown = breakDown;
  const [result] = await db.insert(recipes).values(data).returning();
  res.json(result);
});

app.put('/api/recipes/:id', async (req, res) => {
  const data = req.body;
  let cost = 0;
  const breakDown = [];
  for (const ing of data.ingredients) {
    const ingData = await db.select().from(ingredients).where(eq(ingredients.id, ing.ingredientId)).limit(1)[0];
    const ingCost = ing.portion * ingData.costPerPortion;
    cost += ingCost;
    breakDown.push({ name: ingData.name, portion: ing.portion, cost: ingCost });
  }
  data.costPerServing = cost;
  data.breakDown = breakDown;
  const [result] = await db.update(recipes).set(data).where(eq(recipes.id, req.params.id)).returning();
  res.json(result);
});

// On ingredient update, trigger recipe recalc
app.put('/api/ingredients/:id', async (req, res) => {
  // ...existing code
  const recipesUsing = await db.select().from(recipes).where(sql`ingredients::jsonb @> '[{"ingredientId": ${req.params.id}}]'`);
  for (const recipe of recipesUsing) {
    let newCost = 0;
    const newBreakDown = [];
    for (const ing of recipe.ingredients) {
      const ingData = await db.select().from(ingredients).where(eq(ingredients.id, ing.ingredientId)).limit(1)[0];
      const ingCost = ing.portion * ingData.costPerPortion;
      newCost += ingCost;
      newBreakDown.push({ name: ingData.name, portion: ing.portion, cost: ingCost });
    }
    await db.update(recipes).set({ costPerServing: newCost, breakDown: newBreakDown }).where(eq(recipes.id, recipe.id));
  }
  // ...res
});
3. Frontend Recipes Page (client/src/pages/Recipes.tsx - Full Code)
Sleek card/table, select ingredients from list, add portion, calc cost/breakdown, store card, download PDF.

tsx

Collapse

Unwrap

Copy
import { useEffect, useState } from 'react';
import { Card, CardHeader, CardContent, Input, Select, Button } from "@/components/ui";
import jsPDF from 'jspdf'; // npm i jspdf

const Recipes = () => {
  const [list, setList] = useState([]);
  const [ingredients, setIngredients] = useState([]);
  const [newRecipe, setNewRecipe] = useState({ name: '', ingredients: [] });
  const [editing, setEditing] = useState(null);

  useEffect(() => {
    fetch('/api/recipes').then(r => r.json()).then(setList);
    fetch('/api/ingredients').then(r => r.json()).then(setIngredients);
  }, []);

  const addIngredient = () => setNewRecipe({ ...newRecipe, ingredients: [...newRecipe.ingredients, { ingredientId: '', portion: 0 }] });

  const updateIngredient = (index, key, value) => {
    const updated = [...newRecipe.ingredients];
    updated[index][key] = value;
    setNewRecipe({ ...newRecipe, ingredients: updated });
  };

  const handleSave = async () => {
    if (editing) {
      await fetch(`/api/recipes/${editing}`, { method: 'PUT', body: JSON.stringify(newRecipe), headers: {'Content-Type': 'application/json'} });
    } else {
      await fetch('/api/recipes', { method: 'POST', body: JSON.stringify(newRecipe), headers: {'Content-Type': 'application/json'} });
    }
    setEditing(null);
    setNewRecipe({ name: '', ingredients: [] });
    fetch('/api/recipes').then(r => r.json()).then(setList);
  };

  const downloadPDF = (recipe) => {
    const doc = new jsPDF();
    doc.text(`Recipe: ${recipe.name}`, 10, 10);
    doc.text(`Cost per Serving: ฿${recipe.costPerServing}`, 10, 20);
    doc.text('Breakdown:', 10, 30);
    recipe.breakDown.forEach((ing, i) => doc.text(`${ing.name}: ${ing.portion} - ฿${ing.cost}`, 10, 40 + i * 10));
    doc.save(`${recipe.name}.pdf`);
  };

  return (
    <Card>
      <CardHeader>Recipes</CardHeader>
      <CardContent>
        <Input placeholder="Name" value={newRecipe.name} onChange={(e) => setNewRecipe({ ...newRecipe, name: e.target.value })} />
        {newRecipe.ingredients.map((ing, i) => (
          <div key={i}>
            <Select onChange={(e) => updateIngredient(i, 'ingredientId', e.target.value)}>
              <option>Select Ingredient</option>
              {ingredients.map(ing => <option key={ing.id} value={ing.id}>{ing.name}</option>)}
            </Select>
            <Input type="number" placeholder="Portion" onChange={(e) => updateIngredient(i, 'portion', parseFloat(e.target.value))} />
          </div>
        ))}
        <Button onClick={addIngredient}>Add Ingredient</Button>
        <Button onClick={handleSave}>Save Recipe</Button>
        <Table>
          <TableBody>
            {list.map(recipe => (
              <TableRow key={recipe.id}>
                <TableCell>{recipe.name}</TableCell>
                <TableCell>฿{recipe.costPerServing}</TableCell>
                <TableCell><Button onClick={() => setEditing(recipe.id)}>Edit</Button></TableCell>
                <TableCell><Button onClick={() => downloadPDF(recipe)}>Download PDF</Button></TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </CardContent>
    </Card>
  );
};

export default Recipes;
Test: Load /menu-mgmt/recipes, select ingredients (e.g., buns portion 1), save—cost calc'd, breakdown stored. Edit ingredient price—recipe auto-updates. Download PDF recipe card.
This is simple, data-accurate (auto-recalc), secure (direct API). Test save/download—share if off.